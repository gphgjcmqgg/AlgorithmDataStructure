# AlgorithmDataStructure

算法和数据结构

## 数据结构几种存储结构

1. 线性表，还可细分为顺序表、链表、栈和队列
2. 树结构，包括普通树，二叉树，线索二叉树等
3. 图存储结构

## 算法

即解决问题的方法。同一个问题，使用不同的算法，虽然得到的结果相同，但是耗费的时间和资源是不同的。

### 好算法的标准

首先它必须能够解决这个问题（称为准确性）。其次，通过这个算法编写的程序要求在任何情况下不能崩溃（称为健壮性）。
如果准确性和健壮性都满足，接下来，就要考虑最重要的一点：通过算法编写的程序，运行的效率怎么样。

好算法的标准就是：在符合算法本身的要求的基础上，使用算法编写的程序运行的时间短，运行过程中占用的内存空间少，就可以称这个算法是“好算法”。

### 运行效率

运行效率体现在两方面：

1. 算法的运行时间。（称为“时间复杂度”）
2. 运行算法所需的内存空间大小。（称为“空间复杂度”）

### 时间复杂度的计算

程序由三种结构构成：顺序结构、分支结构和循环结构。顺序结构和分支结构中的每段代码只运行一次；循环结构中的代码的运行时间要看循环的次数。
由于是估算算法的时间复杂度，相比而言，循环结构对算法的执行时间影响更大。所以，算法的时间复杂度，主要看算法中使用到的循环结构中代码循环的次数（称为“频度”）。次数越少，算法的时间复杂度越低。

例如：
a) ++x; s=0;
b) for (int i=1; i<=n; i++) { ++x; s+=x; }
c) for (int i=1; i<=n; i++) { for (int j=1; i<=n; j++) { ++x; s+=x; } }

a 代码的运行了 1 次，b 代码的运行了 n 次，c 代码运行了 n*n 次。

对于上边的例子而言，a 的时间复杂度为O(1)，b 的时间复杂度为O(n)，c 的时间复杂度为为O(n*n)。
如果a、b、c组成一段程序，那么算法的时间复杂度为O(n*n+n+1)。但这么表示是不对的，还需要对n*n+n+1进行简化。
简化的过程总结为3步：

* 去掉运行时间中的所有加法常数。（例如 n2+n+1，直接变为 n*n+n）
* 只保留最高项。（n*n+n 变成 n*n）
* 如果最高项存在但是系数不是1，去掉系数。（n*n 系数为 1）
所以，最终a、b和c合并而成的代码的时间复杂度为O(n*n)。

#### 时间复杂度的表示

算法的时间复杂度的表示方式为：
O(频度)

#### 常用的时间复杂度的排序

列举了几种常见的算法时间复杂度的比较（又小到大）：
O(1)常数阶 < O(logn)对数阶 < O(n)线性阶 < O(n2)平方阶 < O(n3)(立方阶) < O(2n) (指数阶)

#### 拿时间换空间，用空间换时间

谷歌浏览器相比于其他的浏览器，运行速度要快。是因为它占用了更多的内存空间，以空间换取了时间。

算法中，例如判断某个年份是否为闰年时，如果想以时间换取空间，算法思路就是：当给定一个年份时，判断该年份是否能被4或者400整除，如果可以，就是闰年。
如果想以空间换时间的话，判断闰年的思路就是：把所有的年份先判断出来，存储在数组中（年份和数组下标对应），如果是闰年，数组值是1，否则是0；当需要判断某年是否为闰年时，直接看对应的数组值是1还是0，不用计算就可以马上知道。

## 数据的逻辑结构和存储结构

数据存储结构的选择取决于两方面，即数据的逻辑结构和存储结构（又称物理结构）。

1. 逻辑结构: 数据的逻辑结构，简单地理解，就是指的数据之间的逻辑关系。
2. 存储结构（物理结构）:数据的存储结构，也就是物理结构，指的是数据在物理存储空间上选择集中存放还是分散存放。

### 数据的逻辑结构

数据之间的逻辑关系可细分为三类，“一对一”、“一对多”和“多对多”：

通过学习数据结构，我们可以学到 3 种存储结构分别存储这 3 类逻辑关系的数据，换句话说：
线性表用于存储具有“一对一”逻辑关系的数据；
树结构用于存储具有“一对多”关系的数据；
图结构用于存储具有“多对多”关系的数据；

### 数据的存储结构（物理结构）

数据的存储结构，也就是物理结构，指的是数据在物理存储空间上选择集中存放还是分散存放。

假设要存储大小为 10G 的数据
集中存储（底层实现使用的是数组）需要使用一大块连续的物理空间，假设要存储大小为 1G 的数据，若存储设备上没有整块大小超过 1G 的空间，就无法使用顺序存储，此时就要选择链式存储，因为链式存储是随机存储数据，占用的都是存储设备中比较小的存储空间，因此有一定几率可以存储成功。
并且，数据的用途不同，选择的存储结构也不同。将数据进行集中存储有利于后期对数据进行遍历操作，而分散存储更有利于后期增加或删除数据。因此，如果后期需要对数据进行大量的检索（遍历），就选择集中存储；反之，若后期需要对数据做进一步更新（增加或删除），则选择分散存储。

